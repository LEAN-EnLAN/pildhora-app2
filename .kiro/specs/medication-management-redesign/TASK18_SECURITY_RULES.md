# Task 18: Firestore Security Rules for medicationEvents

## Overview

This document describes the Firestore security rules implemented for the `medicationEvents` collection, which stores medication lifecycle events (create, update, delete) generated by patients for caregiver monitoring.

## Security Rules Implementation

### 1. Read Access Control

**Rule**: Only the assigned caregiver can read events

```javascript
allow read: if isSignedIn() && 
  request.auth.uid == resource.data.caregiverId;
```

**Behavior**:
- Caregivers can only read events where they are listed as the `caregiverId`
- Patients cannot read events (even their own)
- Other caregivers cannot read events assigned to different caregivers
- Unauthenticated users cannot read any events

**Use Case**: When a caregiver opens the event registry, they only see events for patients they are assigned to monitor.

### 2. Write Access Control

**Rule**: Only authenticated patients can create events

```javascript
allow create: if isSignedIn() && 
  isValidEventData() &&
  isWithinRateLimit();
```

**Behavior**:
- Only authenticated users can create events
- The `patientId` in the event must match the authenticated user's UID
- Event data must pass validation checks
- Rate limiting is enforced (max 100 events/hour)

**Use Case**: When a patient creates, updates, or deletes a medication, the system generates an event that is stored in Firestore.

### 3. Data Structure Validation

**Rule**: Events must contain all required fields with valid values

```javascript
function isValidEventData() {
  let data = request.resource.data;
  return data.keys().hasAll(['eventType', 'medicationId', 'medicationName', 'patientId', 'caregiverId', 'timestamp', 'syncStatus']) &&
         data.eventType in ['created', 'updated', 'deleted'] &&
         data.medicationId is string &&
         data.medicationName is string &&
         data.patientId is string &&
         data.caregiverId is string &&
         data.timestamp is timestamp &&
         data.syncStatus in ['pending', 'delivered', 'failed'] &&
         data.patientId == request.auth.uid &&
         (!data.keys().hasAny(['medicationData']) || data.medicationData is map) &&
         (!data.keys().hasAny(['changes']) || data.changes is list);
}
```

**Required Fields**:
- `eventType`: Must be one of `'created'`, `'updated'`, or `'deleted'`
- `medicationId`: String identifier for the medication
- `medicationName`: String name of the medication
- `patientId`: String UID of the patient (must match authenticated user)
- `caregiverId`: String UID of the assigned caregiver
- `timestamp`: Firestore Timestamp
- `syncStatus`: Must be one of `'pending'`, `'delivered'`, or `'failed'`

**Optional Fields**:
- `medicationData`: Map containing medication snapshot
- `changes`: List of change objects (for update events)

**Validation Checks**:
- All required fields must be present
- Field types must match expected types
- Enum values must be from allowed sets
- `patientId` must match the authenticated user (prevents spoofing)

### 4. Rate Limiting

**Rule**: Maximum 100 events per hour per patient

**Implementation**: Rate limiting is enforced via Cloud Function rather than security rules due to Firestore security rules query limitations.

**Cloud Function**: `onMedicationEventRateLimit`

```typescript
export const onMedicationEventRateLimit = onDocumentCreated("medicationEvents/{eventId}", async (event) => {
  const patientId = eventData.patientId;
  
  // Count events created by this patient in the last hour
  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
  const recentEventsSnapshot = await admin.firestore()
    .collection('medicationEvents')
    .where('patientId', '==', patientId)
    .where('timestamp', '>', oneHourAgo)
    .get();

  const eventCount = recentEventsSnapshot.size;

  // Log warning at 80% threshold
  if (eventCount >= 80 && eventCount < 100) {
    logger.warn("Patient approaching rate limit", { patientId, eventCount });
  }

  // Delete events that exceed 100/hour
  if (eventCount > 100) {
    await admin.firestore().doc(`medicationEvents/${eventId}`).delete();
    logger.error("Rate limit exceeded - event deleted", { patientId, eventCount });
  }
});
```

**Behavior**:
- Monitors event creation in real-time via Cloud Function trigger
- Counts events created by the patient in the last hour
- Logs warning when patient reaches 80% of limit (80 events)
- Automatically deletes events that exceed 100/hour limit
- Prevents event spam and abuse
- Protects against malicious or buggy clients

**Use Case**: Prevents a patient from accidentally or maliciously creating thousands of events that would overwhelm the caregiver's event registry.

### 5. Update and Delete Access

**Rule**: Only the patient who created the event can update or delete it

```javascript
allow update, delete: if isSignedIn() && 
  request.auth.uid == resource.data.patientId;
```

**Behavior**:
- Patients can update their own events (e.g., change syncStatus)
- Patients can delete their own events
- Caregivers cannot modify or delete events
- Other patients cannot modify events

**Use Case**: Allows the event queue system to update syncStatus from 'pending' to 'delivered' after successful sync.

## Security Guarantees

### ✅ What is Protected

1. **Caregiver Privacy**: Caregivers only see events for their assigned patients
2. **Patient Privacy**: Patients cannot read other patients' events
3. **Data Integrity**: Events cannot be created with invalid or malformed data
4. **Anti-Spoofing**: Patients cannot create events claiming to be from other patients
5. **Rate Limiting**: Prevents event spam and abuse
6. **Audit Trail**: Events cannot be modified by unauthorized users

### ❌ What is NOT Protected

1. **Patient Reading Own Events**: Patients cannot read their own events (by design - events are for caregivers)
2. **Caregiver Writing Events**: Caregivers cannot create events (only patients can)
3. **Cross-Patient Access**: No patient can access another patient's events

## Testing the Security Rules

### Local Testing with Emulator

```bash
# Start Firestore emulator
firebase emulators:start --only firestore

# Run security rules tests
npm test -- firestore-rules
```

### Manual Testing

```bash
# Run the test script
node test-medication-event-security-rules.js
```

The test script validates:
1. ✅ Event creation with valid data
2. ✅ Event data structure validation
3. ✅ Read access control
4. ✅ Different event types (created, updated, deleted)
5. ✅ Rate limiting mechanism
6. ✅ Update and delete operations

### Production Testing

After deploying rules to production:

```bash
# Deploy security rules
firebase deploy --only firestore:rules

# Verify in Firebase Console
# 1. Go to Firestore > Rules
# 2. Check that medicationEvents rules are present
# 3. Use Rules Playground to test scenarios
```

## Integration with Application Code

### Creating Events (Patient App)

```typescript
// In medicationEventService.ts
async function createMedicationEvent(
  eventType: 'created' | 'updated' | 'deleted',
  medication: Medication,
  changes?: ChangeRecord[]
): Promise<void> {
  const event: MedicationEvent = {
    eventType,
    medicationId: medication.id,
    medicationName: medication.name,
    medicationData: medication,
    patientId: medication.patientId,
    caregiverId: medication.caregiverId,
    timestamp: Timestamp.now(),
    syncStatus: 'pending',
    changes: changes || []
  };
  
  // Security rules will validate this data
  await db.collection('medicationEvents').add(event);
}
```

### Reading Events (Caregiver App)

```typescript
// In caregiver event registry
async function loadCaregiverEvents(caregiverId: string): Promise<MedicationEvent[]> {
  // Security rules ensure only events for this caregiver are returned
  const snapshot = await db.collection('medicationEvents')
    .where('caregiverId', '==', caregiverId)
    .orderBy('timestamp', 'desc')
    .limit(50)
    .get();
  
  return snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  })) as MedicationEvent[];
}
```

## Firestore Indexes Required

To support efficient queries with security rules, create these indexes:

```json
{
  "indexes": [
    {
      "collectionGroup": "medicationEvents",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "patientId", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "medicationEvents",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "caregiverId", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "medicationEvents",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "caregiverId", "order": "ASCENDING" },
        { "fieldPath": "eventType", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    }
  ]
}
```

Add these to `firestore.indexes.json` and deploy:

```bash
firebase deploy --only firestore:indexes
```

## Monitoring and Maintenance

### Monitoring Event Creation

```javascript
// Cloud Function to monitor event creation rate
exports.monitorEventRate = functions.firestore
  .document('medicationEvents/{eventId}')
  .onCreate(async (snap, context) => {
    const event = snap.data();
    
    // Check if patient is approaching rate limit
    const recentEvents = await admin.firestore()
      .collection('medicationEvents')
      .where('patientId', '==', event.patientId)
      .where('timestamp', '>', new Date(Date.now() - 3600000))
      .get();
    
    if (recentEvents.size > 80) {
      console.warn(`Patient ${event.patientId} approaching rate limit: ${recentEvents.size}/100`);
    }
  });
```

### Cleanup Old Events

```javascript
// Cloud Function to cleanup events older than 90 days
exports.cleanupOldEvents = functions.pubsub
  .schedule('every 24 hours')
  .onRun(async (context) => {
    const cutoffDate = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
    
    const oldEvents = await admin.firestore()
      .collection('medicationEvents')
      .where('timestamp', '<', cutoffDate)
      .get();
    
    const batch = admin.firestore().batch();
    oldEvents.docs.forEach(doc => {
      batch.delete(doc.ref);
    });
    
    await batch.commit();
    console.log(`Deleted ${oldEvents.size} old events`);
  });
```

## Troubleshooting

### Common Issues

**Issue**: "Missing or insufficient permissions"
- **Cause**: User is not authenticated or not the assigned caregiver
- **Solution**: Ensure user is logged in and caregiverId matches

**Issue**: "Rate limit exceeded"
- **Cause**: Patient created more than 100 events in the last hour
- **Solution**: Wait for the hour window to pass, or investigate why so many events are being created

**Issue**: "Invalid event data"
- **Cause**: Event is missing required fields or has invalid values
- **Solution**: Check that all required fields are present and have correct types

**Issue**: "Cannot read events"
- **Cause**: User is not the assigned caregiver for those events
- **Solution**: Verify caregiverId in the event matches the authenticated user

## Deployment Checklist

- [x] Security rules added to `firestore.rules`
- [x] Test script created (`test-medication-event-security-rules.js`)
- [ ] Firestore indexes added to `firestore.indexes.json`
- [ ] Security rules deployed to production
- [ ] Indexes deployed to production
- [ ] Rules tested in Firebase Console Rules Playground
- [ ] Integration tested with patient app
- [ ] Integration tested with caregiver app
- [ ] Monitoring set up for rate limit warnings
- [ ] Cleanup function scheduled for old events

## References

- **Requirements**: Requirement 6.5 (Caregiver Notification System)
- **Design Document**: Section 3 (Caregiver Notification System)
- **Related Files**:
  - `firestore.rules` - Security rules definition
  - `src/services/medicationEventService.ts` - Event creation service
  - `app/caregiver/events.tsx` - Event registry UI
  - `test-medication-event-security-rules.js` - Test script
